// Code generated by go-swagger; DO NOT EDIT.

package model

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Match match
//
// swagger:model Match
type Match struct {

	// away score
	AwayScore int64 `json:"away_score"`

	// away team
	AwayTeam *Team `json:"away_team,omitempty"`

	// competition
	Competition *Competition `json:"competition,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// f end
	// Format: date-time
	FEnd *strfmt.DateTime `json:"f_end,omitempty"`

	// f start
	// Format: date-time
	FStart *strfmt.DateTime `json:"f_start,omitempty"`

	// has lineups
	HasLineups bool `json:"has_lineups"`

	// home score
	HomeScore int64 `json:"home_score"`

	// home team
	HomeTeam *Team `json:"home_team,omitempty"`

	// Internal Match Id
	ID string `json:"id,omitempty"`

	// match end
	// Format: date-time
	MatchEnd *strfmt.DateTime `json:"match_end,omitempty"`

	// Planned Kick-Off Time
	// Format: date-time
	MatchTime strfmt.DateTime `json:"match_time,omitempty"`

	// match timer
	MatchTimer string `json:"match_timer,omitempty"`

	// match type
	MatchType MatchType `json:"match_type,omitempty"`

	// p end
	// Format: date-time
	PEnd *strfmt.DateTime `json:"p_end,omitempty"`

	// p start
	// Format: date-time
	PStart *strfmt.DateTime `json:"p_start,omitempty"`

	// period
	Period MatchPeriod `json:"period,omitempty"`

	// player count
	PlayerCount int64 `json:"player_count"`

	// rewards
	Rewards []*MatchReward `json:"rewards"`

	// rules
	Rules *MatchRule `json:"rules,omitempty"`

	// s end
	// Format: date-time
	SEnd *strfmt.DateTime `json:"s_end,omitempty"`

	// s start
	// Format: date-time
	SStart *strfmt.DateTime `json:"s_start,omitempty"`

	// status
	Status MatchStatus `json:"status,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`

	// version
	Version int64 `json:"version"`

	// x1 end
	// Format: date-time
	X1End *strfmt.DateTime `json:"x1_end,omitempty"`

	// x1 start
	// Format: date-time
	X1Start *strfmt.DateTime `json:"x1_start,omitempty"`

	// x2 end
	// Format: date-time
	X2End *strfmt.DateTime `json:"x2_end,omitempty"`

	// x2 start
	// Format: date-time
	X2Start *strfmt.DateTime `json:"x2_start,omitempty"`
}

// Validate validates this match
func (m *Match) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAwayTeam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompetition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHomeTeam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatchType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRewards(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSEnd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSStart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateX1End(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateX1Start(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateX2End(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateX2Start(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Match) validateAwayTeam(formats strfmt.Registry) error {
	if swag.IsZero(m.AwayTeam) { // not required
		return nil
	}

	if m.AwayTeam != nil {
		if err := m.AwayTeam.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("away_team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("away_team")
			}
			return err
		}
	}

	return nil
}

func (m *Match) validateCompetition(formats strfmt.Registry) error {
	if swag.IsZero(m.Competition) { // not required
		return nil
	}

	if m.Competition != nil {
		if err := m.Competition.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("competition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("competition")
			}
			return err
		}
	}

	return nil
}

func (m *Match) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateFEnd(formats strfmt.Registry) error {
	if swag.IsZero(m.FEnd) { // not required
		return nil
	}

	if err := validate.FormatOf("f_end", "body", "date-time", m.FEnd.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateFStart(formats strfmt.Registry) error {
	if swag.IsZero(m.FStart) { // not required
		return nil
	}

	if err := validate.FormatOf("f_start", "body", "date-time", m.FStart.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateHomeTeam(formats strfmt.Registry) error {
	if swag.IsZero(m.HomeTeam) { // not required
		return nil
	}

	if m.HomeTeam != nil {
		if err := m.HomeTeam.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("home_team")
			}
			return err
		}
	}

	return nil
}

func (m *Match) validateMatchEnd(formats strfmt.Registry) error {
	if swag.IsZero(m.MatchEnd) { // not required
		return nil
	}

	if err := validate.FormatOf("match_end", "body", "date-time", m.MatchEnd.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateMatchTime(formats strfmt.Registry) error {
	if swag.IsZero(m.MatchTime) { // not required
		return nil
	}

	if err := validate.FormatOf("match_time", "body", "date-time", m.MatchTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateMatchType(formats strfmt.Registry) error {
	if swag.IsZero(m.MatchType) { // not required
		return nil
	}

	if err := m.MatchType.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("match_type")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("match_type")
		}
		return err
	}

	return nil
}

func (m *Match) validatePEnd(formats strfmt.Registry) error {
	if swag.IsZero(m.PEnd) { // not required
		return nil
	}

	if err := validate.FormatOf("p_end", "body", "date-time", m.PEnd.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validatePStart(formats strfmt.Registry) error {
	if swag.IsZero(m.PStart) { // not required
		return nil
	}

	if err := validate.FormatOf("p_start", "body", "date-time", m.PStart.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validatePeriod(formats strfmt.Registry) error {
	if swag.IsZero(m.Period) { // not required
		return nil
	}

	if err := m.Period.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("period")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("period")
		}
		return err
	}

	return nil
}

func (m *Match) validateRewards(formats strfmt.Registry) error {
	if swag.IsZero(m.Rewards) { // not required
		return nil
	}

	for i := 0; i < len(m.Rewards); i++ {
		if swag.IsZero(m.Rewards[i]) { // not required
			continue
		}

		if m.Rewards[i] != nil {
			if err := m.Rewards[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rewards" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rewards" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Match) validateRules(formats strfmt.Registry) error {
	if swag.IsZero(m.Rules) { // not required
		return nil
	}

	if m.Rules != nil {
		if err := m.Rules.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rules")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rules")
			}
			return err
		}
	}

	return nil
}

func (m *Match) validateSEnd(formats strfmt.Registry) error {
	if swag.IsZero(m.SEnd) { // not required
		return nil
	}

	if err := validate.FormatOf("s_end", "body", "date-time", m.SEnd.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateSStart(formats strfmt.Registry) error {
	if swag.IsZero(m.SStart) { // not required
		return nil
	}

	if err := validate.FormatOf("s_start", "body", "date-time", m.SStart.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if err := m.Status.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("status")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("status")
		}
		return err
	}

	return nil
}

func (m *Match) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateX1End(formats strfmt.Registry) error {
	if swag.IsZero(m.X1End) { // not required
		return nil
	}

	if err := validate.FormatOf("x1_end", "body", "date-time", m.X1End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateX1Start(formats strfmt.Registry) error {
	if swag.IsZero(m.X1Start) { // not required
		return nil
	}

	if err := validate.FormatOf("x1_start", "body", "date-time", m.X1Start.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateX2End(formats strfmt.Registry) error {
	if swag.IsZero(m.X2End) { // not required
		return nil
	}

	if err := validate.FormatOf("x2_end", "body", "date-time", m.X2End.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Match) validateX2Start(formats strfmt.Registry) error {
	if swag.IsZero(m.X2Start) { // not required
		return nil
	}

	if err := validate.FormatOf("x2_start", "body", "date-time", m.X2Start.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this match based on the context it is used
func (m *Match) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAwayTeam(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCompetition(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHomeTeam(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMatchType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePeriod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRewards(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Match) contextValidateAwayTeam(ctx context.Context, formats strfmt.Registry) error {

	if m.AwayTeam != nil {

		if swag.IsZero(m.AwayTeam) { // not required
			return nil
		}

		if err := m.AwayTeam.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("away_team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("away_team")
			}
			return err
		}
	}

	return nil
}

func (m *Match) contextValidateCompetition(ctx context.Context, formats strfmt.Registry) error {

	if m.Competition != nil {

		if swag.IsZero(m.Competition) { // not required
			return nil
		}

		if err := m.Competition.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("competition")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("competition")
			}
			return err
		}
	}

	return nil
}

func (m *Match) contextValidateHomeTeam(ctx context.Context, formats strfmt.Registry) error {

	if m.HomeTeam != nil {

		if swag.IsZero(m.HomeTeam) { // not required
			return nil
		}

		if err := m.HomeTeam.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("home_team")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("home_team")
			}
			return err
		}
	}

	return nil
}

func (m *Match) contextValidateMatchType(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.MatchType) { // not required
		return nil
	}

	if err := m.MatchType.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("match_type")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("match_type")
		}
		return err
	}

	return nil
}

func (m *Match) contextValidatePeriod(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Period) { // not required
		return nil
	}

	if err := m.Period.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("period")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("period")
		}
		return err
	}

	return nil
}

func (m *Match) contextValidateRewards(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Rewards); i++ {

		if m.Rewards[i] != nil {

			if swag.IsZero(m.Rewards[i]) { // not required
				return nil
			}

			if err := m.Rewards[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("rewards" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("rewards" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Match) contextValidateRules(ctx context.Context, formats strfmt.Registry) error {

	if m.Rules != nil {

		if swag.IsZero(m.Rules) { // not required
			return nil
		}

		if err := m.Rules.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("rules")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("rules")
			}
			return err
		}
	}

	return nil
}

func (m *Match) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if err := m.Status.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("status")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("status")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Match) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Match) UnmarshalBinary(b []byte) error {
	var res Match
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
